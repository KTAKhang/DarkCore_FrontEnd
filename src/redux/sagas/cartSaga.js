import { call, put, takeLatest } from "redux-saga/effects";
import { toast } from "react-toastify";
import axios from "axios";
import {
  CART_GET_REQUEST,
  cartGetSuccess,
  cartGetFailure,
  CART_ADD_REQUEST,
  cartAddSuccess,
  cartAddFailure,
  CART_UPDATE_REQUEST,
  cartUpdateSuccess,
  cartUpdateFailure,
  CART_REMOVE_REQUEST,
  cartRemoveSuccess,
  cartRemoveFailure,
  CART_CLEAR_REQUEST,
  cartClearSuccess,
  cartClearFailure,
} from "../actions/cartActions";

const API_BASE_URL = "http://localhost:3000";
console.log("üü¢ cartSaga loaded");

// ===== API CALLS C∆† B·∫¢N =====
const apiCall = async (method, url, data, isForm = false) => {
  console.log("üî¥ apiCall: Starting", { method, url, data });

  const token = localStorage.getItem("token");
  console.log("üî¥ apiCall: Token exists?", !!token);
  if (!token) {
    console.error("üî¥ apiCall: No token found");
    throw new Error("No token found");
  }

  try {
    const config = {
      method,
      url: `${API_BASE_URL}${url}`,
      withCredentials: true,
      headers: {
        "Content-Type": isForm ? "multipart/form-data" : "application/json",
        Authorization: `Bearer ${token}`,
      },
      timeout: 5000,
    };

    if (data !== undefined && data !== null) {
      config.data = data;
    }

    const res = await axios(config);
    return res.data;
  } catch (error) {
    // ===== X·ª≠ l√Ω l·ªói h·∫øt h·∫°n token =====
    if (error.response?.status === 401) {
      try {
        const refreshRes = await axios.post(
          `${API_BASE_URL}/auth/refresh-token`,
          {},
          { withCredentials: true }
        );
        const newToken = refreshRes.data?.token?.access_token;
        if (newToken) {
          localStorage.setItem("token", newToken);
          const retryConfig = {
            method,
            url: `${API_BASE_URL}${url}`,
            withCredentials: true,
            headers: {
              "Content-Type": isForm
                ? "multipart/form-data"
                : "application/json",
              Authorization: `Bearer ${newToken}`,
            },
            timeout: 5000,
          };
          if (data !== undefined && data !== null) {
            retryConfig.data = data;
          }
          const retryRes = await axios(retryConfig);
          return retryRes.data;
        }
      } catch (refreshError) {
        localStorage.removeItem("token");
        localStorage.removeItem("user");
        window.location.href = "/login";
        throw new Error("Phi√™n ƒëƒÉng nh·∫≠p h·∫øt h·∫°n, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i");
      }
    }

    // ===== X·ª≠ l√Ω l·ªói chung =====
    const msg =
      error.response?.data?.message ||
      error.response?.data?.error ||
      error.message ||
      "Request failed";

    // üß† CH·ªà LOG L·∫†I, KH√îNG HI·ªÇN TOAST ·ªû ƒê√ÇY
    console.error(
      `API Error [${method.toUpperCase()} ${url}]:`,
      msg,
      error.response?.data
    );

    // üü° TR·∫¢ L·∫†I L·ªñI ‚Äî ƒë·ªÉ saga t·ª± hi·ªÉn th·ªã toast (ch·ªâ 1 c√°i)
    throw error;
  }
};

// ===== SAGAS =====
function* getCartSaga() {
  try {
    const response = yield call(() => apiCall("get", "/cart"));
    if (response.status === "OK") {
      yield put(cartGetSuccess(response.cart));
      toast.success(response.message || "L·∫•y gi·ªè h√†ng th√†nh c√¥ng!");
    } else {
      throw new Error(response.message || "L·∫•y gi·ªè h√†ng th·∫•t b·∫°i");
    }
  } catch (error) {
    const msg = error.message || "L·∫•y gi·ªè h√†ng th·∫•t b·∫°i";
    console.error("getCartSaga error:", msg, error);
    yield put(cartGetFailure(msg));
    toast.error(msg);
  }
}

function* addCartSaga(action) {
  console.log("üü¢ watchCartAdd started");
  console.log("Saga received:", action.payload);
  try {
    const response = yield call(() =>
      apiCall("post", "/cart/add", action.payload)
    );
    console.log("üî¥ addCartSaga: After apiCall", response);

    if (response.status === "OK") {
      yield put(cartAddSuccess(response.cart));
      toast.success(response.message || "Th√™m v√†o gi·ªè h√†ng th√†nh c√¥ng!");
    } else {
      throw new Error(response.message || "Th√™m v√†o gi·ªè h√†ng th·∫•t b·∫°i");
    }
  } catch (error) {
    console.error("üî¥ addCartSaga: CATCH ERROR", error);

    // üü° FIX: L·∫•y backendMsg t·ª´ c·∫£ error.message (cho throw new Error) v√† error.response (cho Axios error)
    let backendMsg = "";
    if (error.response) {
      backendMsg = error.response.data?.message || error.message || "";
    } else {
      backendMsg = error.message || "";
    }

    // üü° TH√äM X·ª¨ L√ù L·ªñI V∆Ø·ª¢T T·ªíN KHO
    if (backendMsg.includes("exceeds stock")) {
      toast.warning("S·ªë l∆∞·ª£ng s·∫£n ph·∫©m v∆∞·ª£t qu√° t·ªìn kho!");
    } else if (backendMsg.includes("not found")) {
      toast.error("S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a!");
    } else {
      toast.error(backendMsg || "Th√™m v√†o gi·ªè h√†ng th·∫•t b·∫°i!"); // üü° S·ª¨A: D√πng backendMsg ƒë·ªÉ toast c·ª• th·ªÉ h∆°n, tr√°nh generic
    }

    yield put(cartAddFailure(backendMsg || "Th√™m v√†o gi·ªè h√†ng th·∫•t b·∫°i"));
  }
}

function* updateCartSaga(action) {
  try {
    const { productId, quantity } = action.payload;
    const response = yield call(() =>
      apiCall("put", `/cart/update/${productId}`, { quantity })
    );

    if (response.error) {
      throw new Error(response.error);
    }

    if (response.status === "OK") {
      yield put(cartUpdateSuccess(response.cart));
      toast.success(response.message || "C·∫≠p nh·∫≠t gi·ªè h√†ng th√†nh c√¥ng!");
    } else {
      throw new Error(response.message || "C·∫≠p nh·∫≠t gi·ªè h√†ng th·∫•t b·∫°i");
    }
  } catch (error) {
    const backendMsg = error.response?.data?.message || "";
    if (backendMsg.includes("exceeds stock")) {
      toast.warning("Kh√¥ng th·ªÉ tƒÉng th√™m ‚Äî v∆∞·ª£t qu√° t·ªìn kho!");
    } else {
      toast.error("S·∫£n ph·∫©m v∆∞·ª£t qu√° t·ªìn kho");
    }

    yield put(cartUpdateFailure(backendMsg || "C·∫≠p nh·∫≠t gi·ªè h√†ng th·∫•t b·∫°i"));
  }
}

function* removeCartSaga(action) {
  try {
    const { productId } = action.payload;
    const response = yield call(() =>
      apiCall("delete", `/cart/remove/${productId}`)
    );
    if (response.status === "OK") {
      yield put(cartRemoveSuccess(response.cart));
      toast.success(
        response.message || "X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng th√†nh c√¥ng!"
      );
    } else {
      throw new Error(
        response.message || "X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng th·∫•t b·∫°i"
      );
    }
  } catch (error) {
    const msg = error.message || "X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng th·∫•t b·∫°i";
    console.error("removeCartSaga error:", msg, error.response?.data);
    yield put(cartRemoveFailure(msg));
    toast.error(msg);
  }
}

function* clearCartSaga() {
  try {
    const response = yield call(() => apiCall("delete", "/cart/clear"));
    if (response.status === "OK") {
      yield put(cartClearSuccess(response.cart));
      toast.success(response.message || "X√≥a to√†n b·ªô gi·ªè h√†ng th√†nh c√¥ng!");
    } else {
      throw new Error(response.message || "X√≥a to√†n b·ªô gi·ªè h√†ng th·∫•t b·∫°i");
    }
  } catch (error) {
    const msg = error.message || "X√≥a to√†n b·ªô gi·ªè h√†ng th·∫•t b·∫°i";
    console.error("clearCartSaga error:", msg, error);
    yield put(cartClearFailure(msg));
    toast.error(msg);
  }
}

// ===== ROOT SAGA =====
export default function* cartSaga() {
  try {
    console.log("üî¥ cartSaga: Starting execution");
    yield takeLatest(CART_GET_REQUEST, getCartSaga);
    yield takeLatest(CART_ADD_REQUEST, addCartSaga);
    yield takeLatest(CART_UPDATE_REQUEST, updateCartSaga);
    yield takeLatest(CART_REMOVE_REQUEST, removeCartSaga);
    yield takeLatest(CART_CLEAR_REQUEST, clearCartSaga);
    console.log("üî¥ cartSaga: All takeLatest registered");
  } catch (error) {
    console.error("üî¥ cartSaga ERROR:", error);
  }
}
